var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs", "child_process", "path", "./config", "./utils", "./Logger", "./logMessages", "inquirer", "./server", "./constants", "./PluginManager", "progress"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs_1 = __importDefault(require("fs"));
    const cp = __importStar(require("child_process"));
    const path_1 = __importDefault(require("path"));
    const config_1 = __importDefault(require("./config"));
    const Utils = __importStar(require("./utils"));
    const Logger_1 = require("./Logger");
    const logMessages_1 = require("./logMessages");
    const inquirer_1 = __importDefault(require("inquirer"));
    const server_1 = require("./server");
    const constants_1 = require("./constants");
    const PluginManager_1 = __importDefault(require("./PluginManager"));
    const progress_1 = __importDefault(require("progress"));
    const fsp = fs_1.default.promises;
    class AppManager {
        constructor() { }
        async writeManifestFile(man) {
            return fsp.writeFile(config_1.default.getManifestPath(), JSON.stringify(man, null, 2));
        }
        async writeNewFiles(file, parentDir, content, skipFileCheck) {
            let exists = true;
            if (!skipFileCheck) {
                let files = await fsp.readdir(parentDir);
                let matchingFiles = files.filter(f => {
                    let reg = new RegExp(file.name + "\\.*$");
                    return reg.test(f);
                });
                exists = matchingFiles.length > 0;
            }
            if (skipFileCheck || !exists) {
                await fsp.writeFile(path_1.default.join(parentDir, `${file.name}.${file.type}`), content);
            }
        }
        async createNewFiles(manifest, skipFileCheck) {
            const { tables } = manifest;
            for (let tableName in tables) {
                let table = tables[tableName];
                let tableFolder = path_1.default.join(config_1.default.getSourcePath(), tableName);
                for (let recKey in table.records) {
                    const rec = table.records[recKey];
                    let recPath = path_1.default.join(tableFolder, rec.name);
                    await fsp.mkdir(recPath, { recursive: true });
                    for (let file of rec.files) {
                        const content = file.content || "";
                        await this.writeNewFiles(file, recPath, content, skipFileCheck);
                        delete file.content;
                    }
                }
            }
        }
        async processManifest(manifest, skipFileCheckOnFileGeneration) {
            if (!skipFileCheckOnFileGeneration &&
                typeof skipFileCheckOnFileGeneration !== "boolean") {
                skipFileCheckOnFileGeneration = false;
            }
            const skipFileCheck = skipFileCheckOnFileGeneration;
            await this.createNewFiles(manifest, skipFileCheck);
            await this.writeManifestFile(manifest);
        }
        async downloadWithFiles(scope, skipFileCheck) {
            try {
                let answers = await inquirer_1.default.prompt([
                    {
                        type: "confirm",
                        name: "confirmed",
                        message: "Downloading will overwrite manifest and files. Are you sure?",
                        default: false
                    }
                ]);
                if (!answers["confirmed"]) {
                    return;
                }
                Logger_1.logger.info("Downloading manifest and files...");
                let man = await server_1.getManifestWithFiles(scope);
                Logger_1.logger.info("Creating local files from manifest...");
                await this.processManifest(man, skipFileCheck);
                Logger_1.logger.success("Download complete ✅");
            }
            catch (e) {
                Logger_1.logger.error("Encountered error while performing download ❌");
                Logger_1.logger.error(e.toString());
            }
        }
        async syncManifest() {
            try {
                let curManifest = await config_1.default.getManifest();
                if (!curManifest) {
                    throw new Error("No manifest file loaded!");
                }
                try {
                    Logger_1.logger.info("Downloading fresh manifest...");
                    let newManifest = await server_1.getManifest(curManifest.scope);
                    Logger_1.logger.info("Writing new manifest file...");
                    this.writeManifestFile(newManifest);
                    Logger_1.logger.info("Finding and creating missing files...");
                    await this.reconcileDifferences(newManifest);
                    config_1.default.updateManifest(newManifest);
                    Logger_1.logger.success("Refresh complete! ✅");
                }
                catch (e) {
                    Logger_1.logger.error("Encountered error while refreshing! ❌");
                    Logger_1.logger.error(e.toString());
                }
            }
            catch (e) {
                Logger_1.logger.error("Encountered error while refreshing! ❌");
                Logger_1.logger.error(e.toString());
            }
        }
        async reconcileDifferences(manifest) {
            try {
                let missing = await this.determineMissing(manifest);
                let missingFileMap = await server_1.getMissingFiles(missing);
                await this.loadMissingFiles(missingFileMap);
            }
            catch (e) {
                throw e;
            }
        }
        async determineMissing(manifest) {
            try {
                let missing = {};
                const { tables } = manifest;
                //go through each table
                for (let tableName in tables) {
                    let table = tables[tableName];
                    let tablePath = path_1.default.join(config_1.default.getSourcePath(), tableName);
                    try {
                        await fsp.access(tablePath, fs_1.default.constants.F_OK);
                    }
                    catch (e) {
                        this.noteMissingTable(missing, table, tableName);
                        continue;
                    }
                    //go through records
                    for (let recName in table.records) {
                        let record = table.records[recName];
                        let recPath = path_1.default.join(tablePath, recName);
                        try {
                            await fsp.access(recPath, fs_1.default.constants.F_OK);
                        }
                        catch (e) {
                            this.noteMissingRecord(missing, record, tableName);
                            continue;
                        }
                        //go through files
                        for (let file of record.files) {
                            let fileList = await fsp.readdir(recPath);
                            let matchingFiles = fileList.filter(f => {
                                let reg = new RegExp(file.name + ".*$");
                                return reg.test(f);
                            });
                            let exists = matchingFiles.length > 0;
                            if (!exists) {
                                this.noteMissingFile(missing, file, tableName, record);
                            }
                        }
                    }
                }
                return missing;
            }
            catch (e) {
                throw e;
            }
        }
        noteMissingFile(missingObj, file, tableName, record) {
            if (!missingObj.hasOwnProperty(tableName)) {
                missingObj[tableName] = {};
            }
            if (!missingObj[tableName].hasOwnProperty(record.sys_id)) {
                missingObj[tableName][record.sys_id] = [];
            }
            missingObj[tableName][record.sys_id].push({
                name: file.name,
                type: file.type
            });
        }
        noteMissingRecord(missingObj, record, tableName) {
            for (let file of record.files) {
                this.noteMissingFile(missingObj, file, tableName, record);
            }
        }
        noteMissingTable(missingObj, table, tableName) {
            for (let recName in table.records) {
                let record = table.records[recName];
                this.noteMissingRecord(missingObj, record, tableName);
            }
        }
        async loadMissingFiles(fileMap) {
            try {
                for (let tableName in fileMap) {
                    let tablePath = path_1.default.join(config_1.default.getSourcePath(), tableName);
                    let tableConfig = fileMap[tableName];
                    for (let recName in tableConfig.records) {
                        let recPath = path_1.default.join(tablePath, recName);
                        let record = tableConfig.records[recName];
                        try {
                            await fsp.access(recPath, fs_1.default.constants.F_OK);
                        }
                        catch (e) {
                            await fsp.mkdir(recPath, { recursive: true });
                        }
                        for (let file of record.files) {
                            let filePath = path_1.default.join(recPath, `${file.name}.${file.type}`);
                            await fsp.writeFile(filePath, file.content || "");
                        }
                    }
                }
            }
            catch (e) {
                throw new Error("failed to load missing files");
            }
        }
        async getFilePaths(pathString) {
            let pathPromises = pathString
                .split(constants_1.PATH_DELIMITER)
                .filter(cur => {
                //make sure it isn't blank
                if (cur && cur !== "") {
                    //make sure it exists
                    let resolvedPath = path_1.default.resolve(process.cwd(), cur);
                    return fs_1.default.existsSync(resolvedPath);
                }
                else {
                    return false;
                }
            })
                .map(async (cur) => {
                let resolvedPath = path_1.default.resolve(process.cwd(), cur);
                let stats = await fsp.stat(resolvedPath);
                if (stats.isDirectory()) {
                    return await this.loadList(resolvedPath);
                }
                else {
                    return [resolvedPath];
                }
            });
            let pathArrays = await Promise.all(pathPromises);
            let paths = pathArrays.reduce((acc, cur) => {
                return acc.concat(cur);
            }, []);
            Logger_1.logger.silly(`${paths.length} paths found...`);
            Logger_1.logger.silly(JSON.stringify(paths, null, 2));
            return paths;
        }
        async pushSpecificFiles(pathString, skipPrompt = false) {
            try {
                let paths = await this.getFilePaths(pathString);
                let fileContexts = await this.parseFileParams(paths);
                Logger_1.logger.info(`${fileContexts.length} files to push...`);
                Logger_1.logger.silly(JSON.stringify(fileContexts.map(ctx => ctx.filePath), null, 2));
                if (skipPrompt || (await this.canPush())) {
                    try {
                        const resultSet = await server_1.pushFiles(process.env.SN_INSTANCE || "", fileContexts);
                        logMessages_1.logMultiFilePush(fileContexts, true, resultSet);
                    }
                    catch (e) {
                        logMessages_1.logMultiFilePush(fileContexts, false, [], e);
                    }
                }
            }
            catch (e) {
                throw e;
            }
        }
        async loaddir(dirPath, list) {
            try {
                let files = await fsp.readdir(dirPath);
                for (let f of files) {
                    let filep = path_1.default.join(dirPath, f);
                    let stats = await fsp.stat(filep);
                    if (stats.isDirectory()) {
                        await this.loaddir(filep, list);
                    }
                    else {
                        list.push(filep);
                    }
                }
            }
            catch (e) {
                throw e;
            }
        }
        async parseFileParams(files) {
            return await Utils.getParsedFilesPayload(files);
        }
        async loadList(directory) {
            let list = [];
            await this.loaddir(directory, list);
            return list;
        }
        async canPush() {
            const targetServer = process.env.SN_INSTANCE || "";
            if (!targetServer) {
                Logger_1.logger.error("No server configured for push!");
                return false;
            }
            try {
                let answers = await inquirer_1.default.prompt([
                    {
                        type: "confirm",
                        name: "confirmed",
                        message: "Pushing will overwrite code in your instance. Are you sure?",
                        default: false
                    }
                ]);
                if (!answers["confirmed"]) {
                    return false;
                }
                return true;
            }
            catch (e) {
                return false;
            }
        }
        async pushAllFiles(skipPrompt = false) {
            try {
                this.pushSpecificFiles(config_1.default.getSourcePath(), skipPrompt);
            }
            catch (e) {
                throw e;
            }
        }
        async buildFile(filePayload, source, build) {
            const { filePath, targetField } = filePayload;
            const fileContents = await PluginManager_1.default.getFinalFileContents(filePayload);
            let ext = "js";
            if (targetField === "css")
                ext = "css";
            if (targetField === "html")
                ext = "html";
            let pathArr = path_1.default
                .join(build, path_1.default.relative(source, filePath))
                .split(".")
                .slice(0, -1);
            pathArr.push(ext);
            const newPath = pathArr.join(".");
            const folderPath = path_1.default.dirname(newPath);
            try {
                await fsp.access(folderPath, fs_1.default.constants.F_OK);
            }
            catch (e) {
                await fsp.mkdir(folderPath, { recursive: true });
            }
            try {
                await fsp.writeFile(newPath, fileContents);
            }
            catch (e) {
                throw e;
            }
        }
        async buildFiles() {
            const resultSet = [];
            try {
                let source = config_1.default.getSourcePath();
                let build = config_1.default.getBuildPath();
                let paths = await this.getFilePaths(source);
                Logger_1.logger.info(`Building ${paths.length} files`);
                let fileContexts = await this.parseFileParams(paths);
                let progBar;
                if (Logger_1.logger.getLogLevel() === "info") {
                    progBar = new progress_1.default(":bar :current/:total (:percent)", {
                        total: fileContexts.length,
                        width: 60
                    });
                }
                try {
                    let resultsPromises = fileContexts.map(ctx => {
                        const pushPromise = this.buildFile(ctx, source, build);
                        pushPromise
                            .then(() => {
                            if (progBar) {
                                progBar.tick();
                            }
                        })
                            .catch(e => {
                            if (progBar) {
                                progBar.tick();
                            }
                            return false;
                        });
                        return true;
                    });
                    const results = await Promise.all(resultsPromises);
                    resultSet.push(...results);
                    logMessages_1.logMultiFileBuild(fileContexts, true, resultSet);
                }
                catch (e) {
                    logMessages_1.logMultiFileBuild(fileContexts, false, [], e);
                }
            }
            catch (e) {
                throw e;
            }
        }
        async canDeploy() {
            const targetServer = process.env.SN_INSTANCE || "";
            if (!targetServer) {
                Logger_1.logger.error("No server configured for deploy!");
                return false;
            }
            try {
                let answers = await inquirer_1.default.prompt([
                    {
                        type: "confirm",
                        name: "confirmed",
                        message: "Deploying will overwrite code in your instance. Are you sure?",
                        default: false
                    }
                ]);
                if (!answers["confirmed"]) {
                    return false;
                }
                return true;
            }
            catch (e) {
                return false;
            }
        }
        async deployFiles(skipPrompt = false) {
            try {
                let paths = config_1.default.getDiffFile().changed;
                let deployDiff = false;
                if (paths && paths.length > 0) {
                    let answers = await inquirer_1.default.prompt([
                        {
                            type: "confirm",
                            name: "confirmed",
                            message: "Would you like to deploy only files changed in your diff file?",
                            default: false
                        }
                    ]);
                    if (answers["confirmed"])
                        deployDiff = true;
                }
                if (!deployDiff) {
                    const build = config_1.default.getBuildPath();
                    paths = await this.getFilePaths(build);
                }
                let fileContexts = await this.parseFileParams(paths);
                Logger_1.logger.info(`${fileContexts.length} files to deploy...`);
                Logger_1.logger.silly(JSON.stringify(fileContexts.map(ctx => ctx.filePath), null, 2));
                if (skipPrompt || (await this.canDeploy())) {
                    try {
                        const resultSet = await server_1.deployFiles(process.env.SN_INSTANCE || "", fileContexts);
                        logMessages_1.logDeploy(fileContexts, true, resultSet);
                    }
                    catch (e) {
                        logMessages_1.logDeploy(fileContexts, false, [], e);
                    }
                }
            }
            catch (e) {
                throw e;
            }
        }
        async checkScope(swapScope) {
            try {
                let man = config_1.default.getManifest();
                if (man) {
                    let scopeObj = await server_1.getCurrentScope();
                    if (scopeObj.scope === man.scope) {
                        return {
                            match: true,
                            sessionScope: scopeObj.scope,
                            manifestScope: man.scope
                        };
                    }
                    else if (swapScope) {
                        const swappedScopeObj = await this.swapScope(man.scope);
                        return {
                            match: swappedScopeObj.scope === man.scope,
                            sessionScope: swappedScopeObj.scope,
                            manifestScope: man.scope
                        };
                    }
                    else {
                        return {
                            match: false,
                            sessionScope: scopeObj.scope,
                            manifestScope: man.scope
                        };
                    }
                }
                //first time case
                return {
                    match: true,
                    sessionScope: "",
                    manifestScope: ""
                };
            }
            catch (e) {
                throw e;
            }
        }
        async swapScope(currentScope) {
            try {
                const scopeId = await server_1.getScopeId(currentScope);
                await server_1.swapServerScope(scopeId);
                const scopeObj = await server_1.getCurrentScope();
                return scopeObj;
            }
            catch (e) {
                throw e;
            }
        }
        gitDiff(target) {
            return new Promise((resolve, reject) => {
                const cmdStr = `git diff --name-status ${target}...`;
                cp.exec(cmdStr, (err, stdout, stderr) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(this.formatGitFiles(stdout.trim()));
                    }
                });
            });
        }
        async writeDiff(files) {
            let paths = await this.getFilePaths(files);
            fsp.writeFile(config_1.default.getDiffPath(), JSON.stringify({ changed: paths }));
        }
        async formatGitFiles(gitFiles) {
            const baseRepoPath = await this.getRepoRootDir();
            const workspaceDir = process.cwd();
            const fileSplit = gitFiles.split(/\r?\n/);
            const fileArray = [];
            fileSplit.forEach(diffFile => {
                if (diffFile !== "") {
                    const modCode = diffFile.charAt(0);
                    if (modCode !== "D") {
                        const filePath = diffFile.substr(1, diffFile.length - 1).trim();
                        if (this.isValidScope(filePath, workspaceDir, baseRepoPath)) {
                            Logger_1.logger.info(diffFile);
                            const absFilePath = path_1.default.resolve(baseRepoPath, filePath);
                            fileArray.push(absFilePath);
                        }
                    }
                }
            });
            return fileArray.join(constants_1.PATH_DELIMITER);
        }
        getRepoRootDir() {
            return new Promise((resolve, reject) => {
                cp.exec("git rev-parse --show-toplevel", (err, stdout, stderr) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(stdout.trim());
                    }
                });
            });
        }
        isValidScope(file, scope, baseRepoPath) {
            const relativePath = path_1.default.relative(baseRepoPath, scope);
            return file.startsWith(relativePath) ? true : false;
        }
        /**
         * Creates a new update set and assigns it to the current user.
         * @param updateSetName - does not create update set if value is blank
         * @param skipPrompt - will not prompt user to verify update set name
         *
         */
        async createAndAssignUpdateSet(updateSetName = "", skipPrompt = false) {
            if (updateSetName !== "") {
                if (await this.promptForNewUpdateSet(updateSetName, skipPrompt)) {
                    const updateSetSysId = await server_1.createUpdateSet(updateSetName);
                    Logger_1.logger.debug(`New Update Set Created(${updateSetName}) sys_id:${updateSetSysId}`);
                    const userSysId = await server_1.getUserSysId();
                    const curUpdateSetUserPrefId = await server_1.getCurrentUpdateSetUserPref(userSysId);
                    if (curUpdateSetUserPrefId !== "") {
                        await server_1.updateCurrentUpdateSetUserPref(updateSetSysId, curUpdateSetUserPrefId);
                    }
                    else {
                        await server_1.createCurrentUpdateSetUserPref(updateSetSysId, userSysId);
                    }
                }
                else {
                    process.exit(0);
                }
            }
        }
        async promptForNewUpdateSet(updateSetName, skipPrompt = false) {
            try {
                if (skipPrompt)
                    return true;
                let answers = await inquirer_1.default.prompt([
                    {
                        type: "confirm",
                        name: "confirmed",
                        message: `A new Update Set "${updateSetName}" will be created for these pushed changes. Do you want to proceed?`,
                        default: false
                    }
                ]);
                if (!answers["confirmed"]) {
                    return false;
                }
                return true;
            }
            catch (e) {
                return false;
            }
        }
    }
    exports.default = new AppManager();
});
