var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./config", "./Watcher", "./AppManager", "./wizard", "./Logger", "./logMessages", "./server"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const config_1 = __importDefault(require("./config"));
    const Watcher_1 = require("./Watcher");
    const AppManager_1 = __importDefault(require("./AppManager"));
    const wizard_1 = require("./wizard");
    const Logger_1 = require("./Logger");
    const logMessages_1 = require("./logMessages");
    const server_1 = require("./server");
    async function scopeCheck(successFunc, swapScopes = false) {
        try {
            const scopeCheck = await AppManager_1.default.checkScope(swapScopes);
            if (!scopeCheck.match) {
                logMessages_1.scopeCheckMessage(scopeCheck);
                // Throw exception to register this as an error
                throw new Error();
            }
            else {
                successFunc();
            }
        }
        catch (e) {
            Logger_1.logger.error("Failed to check your scope! You may want to make sure your project is configured correctly or run `npx sinc init`");
            // Throw exception to register this as an error
            throw e;
        }
    }
    function setLogLevel(args) {
        Logger_1.logger.setLogLevel(args.logLevel);
    }
    async function devCommand(args) {
        setLogLevel(args);
        scopeCheck(async () => {
            Watcher_1.startWatching(config_1.default.getSourcePath());
            logMessages_1.devModeLog();
            let refresher = () => {
                refreshCommand(args, false);
            };
            let interval = config_1.default.getRefresh();
            if (interval && interval > 0) {
                Logger_1.logger.info(`Checking for new manifest files every ${interval} seconds`);
                setInterval(refresher, interval * 1000);
            }
        });
    }
    exports.devCommand = devCommand;
    async function refreshCommand(args, log = true) {
        setLogLevel(args);
        scopeCheck(async () => {
            try {
                if (!log)
                    setLogLevel({ logLevel: "warn" });
                await AppManager_1.default.syncManifest();
                setLogLevel(args);
            }
            catch (e) {
                throw e;
            }
        });
    }
    exports.refreshCommand = refreshCommand;
    async function pushCommand(args) {
        setLogLevel(args);
        scopeCheck(async () => {
            try {
                // Does not create update set if updateSetName is blank
                await AppManager_1.default.createAndAssignUpdateSet(args.updateSet, args.ci);
                if (args.target !== undefined) {
                    if (args.target !== "") {
                        await AppManager_1.default.pushSpecificFiles(args.target, args.ci);
                    }
                }
                else if (args.diff !== "") {
                    const files = await AppManager_1.default.gitDiff(args.diff);
                    await AppManager_1.default.pushSpecificFiles(files, args.ci);
                }
                else {
                    await AppManager_1.default.pushAllFiles(args.ci);
                }
            }
            catch (e) {
                throw e;
            }
        }, args.scopeSwap);
    }
    exports.pushCommand = pushCommand;
    async function downloadCommand(args) {
        setLogLevel(args);
        try {
            await AppManager_1.default.downloadWithFiles(args.scope);
        }
        catch (e) {
            throw e;
        }
    }
    exports.downloadCommand = downloadCommand;
    async function initCommand(args) {
        setLogLevel(args);
        try {
            await wizard_1.startWizard();
        }
        catch (e) {
            throw e;
        }
    }
    exports.initCommand = initCommand;
    async function buildCommand(args) {
        setLogLevel(args);
        try {
            if (args.diff !== "") {
                let files = await AppManager_1.default.gitDiff(args.diff);
                AppManager_1.default.writeDiff(files);
            }
            await AppManager_1.default.buildFiles();
        }
        catch (e) {
            throw e;
        }
    }
    exports.buildCommand = buildCommand;
    async function deployCommand(args) {
        setLogLevel(args);
        try {
            await AppManager_1.default.deployFiles();
        }
        catch (e) {
            throw e;
        }
    }
    exports.deployCommand = deployCommand;
    async function statusCommand() {
        try {
            let scopeObj = await server_1.getCurrentScope();
            Logger_1.logger.info(`Instance: ${process.env.SN_INSTANCE}`);
            Logger_1.logger.info(`Scope: ${scopeObj.scope}`);
            Logger_1.logger.info(`User: ${process.env.SN_USER}`);
        }
        catch (e) {
            throw e;
        }
    }
    exports.statusCommand = statusCommand;
});
